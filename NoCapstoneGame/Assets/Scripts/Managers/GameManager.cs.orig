using System.Collections;
using System.Collections.Generic;
using UnityEngine;
<<<<<<< HEAD
using UnityEngine.Android;
=======
>>>>>>> soundManager
using UnityEngine.Events;
using UnityEngine.InputSystem;
using UnityEngine.SceneManagement;

<<<<<<< HEAD
/// <summary>
/// Parameters:
///     menus:
///         when the player is in any menu OTHER THAN paued (any with thier own scene)
///         
///     gameplay:  
///         when the game is running
///         
///     paused: 
///         when in the gameplay scene, but gameplay is paused (pause menu)
/// </summary>
public enum GameState
{
    menus, gameplay, paused
}

=======
>>>>>>> soundManager
public class GameManager : MonoBehaviour
{
    private static GameManager _instance;
    public static GameManager Instance { get { return _instance; } }

<<<<<<< HEAD
    public PlayerController playerController;
    public SpeedManager speedManager;

=======
>>>>>>> soundManager
    [SerializeField] public Camera gameplayCamera;
    [SerializeField] public string hazardTag;
    [SerializeField] public string playerTag;

    public Vector2 cameraBounds;

    // The current health of the player
<<<<<<< HEAD
    [SerializeField] private float playerHealth;

    [SerializeField] private float maxEnergyLevel;
    // The current energy level (max charge amount) 
=======
    private int playerHealth;

    [SerializeField] private float maxEnergyLevel;
    // The current energy level (max charge amount) (for MVP)
>>>>>>> soundManager
    [SerializeField] private float energyLevel;

    // The current energy charge (for MVP)
    [SerializeField] private float chargeLevel;

<<<<<<< HEAD
    public float maxFired;
    [SerializeField] public float firedLevel;

    public float Speed;
    [Tooltip("setting speed to ints (or at least floats at similar sizes to ints, such as 1.75) is more intuitive, but causes insane speeds. This scales it down as well as offering parameterization of how quickly speed increases")]
    [SerializeField] private float speedScale;

    [Tooltip("This modifies asteroid values to make the game harder with each level")]
    [SerializeField] private float levelScale = 1;

    [SerializeField] public GameObject explosionPrefab; //I will hopefully not need to keep this here (bobby)
=======
    [SerializeField] private float speed;
    [Tooltip("setting speed to ints is more intuitive, but causes insane speeds. This scales it down as well as offering parameterization of how quickly speed increases")]
    [SerializeField] private float speedScale;

    [SerializeField] public SFXManager sfxManager;
>>>>>>> soundManager

    // The current score (probably measured in distance)
    private int score;

    //whether or not the game is currently paused
    public bool paused { get; private set; } //may want to expand this an enum

<<<<<<< HEAD
    [SerializeField] public GameState gameState { get; private set; }

    public UnityEvent OnPlayerHeal;
    public UnityEvent OnPlayerHurt;
    public UnityEvent OnPlayerDeath;

    public UnityEvent OnEnergyChange;
    public UnityEvent OnChargeChange;
    public UnityEvent OnFiredChange;

    public UnityEvent OnGameEnterMenus;
    public UnityEvent OnGamePause;
    public UnityEvent OnGameResume;



    void Awake()
    {
=======
    public UnityEvent OnPlayerHeal;
    public UnityEvent OnPlayerHurt;
    public UnityEvent OnPlayerDeath;
    public UnityEvent OnEnergyChange;
    public UnityEvent OnChargeChange;

    public UnityEvent OnGameTogglePause;

    void Awake()
    {
        paused = false;

>>>>>>> soundManager
        if (_instance == null)
        {
            _instance = this;
        }
        else
        {
            Destroy(this.gameObject);
        }

<<<<<<< HEAD
        cameraBounds = new Vector2(gameplayCamera.orthographicSize - 1, (gameplayCamera.orthographicSize * gameplayCamera.aspect) - 1.5f);
=======
        cameraBounds = new Vector2(gameplayCamera.orthographicSize, gameplayCamera.orthographicSize * gameplayCamera.aspect);
>>>>>>> soundManager

        // Initilize playerHealth to 0, the player will call AddPlayerHealth() when the game starts.
        // This allows max health to be configued in the player object or at runtime
        playerHealth = 0;
        Time.timeScale = 1;
        Cursor.visible = false;
<<<<<<< HEAD
        speedManager = playerController.speedManager;
=======
>>>>>>> soundManager
    }

    private void Start()
    {
        //OnGameTogglePause.AddListener(TogglePause);
    }

<<<<<<< HEAD
    private void Update()
    {

    }

    public void AddPlayerHealth(float amount)
=======
    public void AddPlayerHealth(int amount)
>>>>>>> soundManager
    {
        playerHealth += amount;
        OnPlayerHeal.Invoke();
    }

<<<<<<< HEAD
    public void RemovePlayerHealth(float amount)
=======
    public void RemovePlayerHealth(int amount)
>>>>>>> soundManager
    {
        playerHealth -= amount;
        OnPlayerHurt.Invoke();
        if (playerHealth <= 0)
        {
            KillPlayer();
        }
    }

    public void KillPlayer()
    {
        playerHealth = 0;
        OnPlayerDeath.Invoke();
    }

<<<<<<< HEAD
    public float GetPlayerHealth()
=======
    public int GetPlayerHealth()
>>>>>>> soundManager
    {
        return playerHealth;
    }


    public void UpdateEnergy(float amount)
    {
<<<<<<< HEAD
        //energyLevel = Mathf.Min(energyLevel+ amount, maxEnergyLevel);
        energyLevel = Mathf.Max(energyLevel+ amount, 0);

        if (amount > 0)
        {
            //playerController.energyDecayTime = 0; 
        }
        

        OnEnergyChange.Invoke();
    }


=======
        energyLevel = Mathf.Min(energyLevel+ amount, maxEnergyLevel);
        OnEnergyChange.Invoke();
    }

>>>>>>> soundManager
    public void ResetEnergy()
    {
        energyLevel = 0;
        OnEnergyChange.Invoke();
    }

    public float GetEnergy() => energyLevel;

<<<<<<< HEAD
    public void UpdateFired(float amount)
    {
        firedLevel = Mathf.Min(firedLevel + amount, maxFired);
        firedLevel = Mathf.Max(firedLevel, 0);

        OnFiredChange.Invoke();
    }


=======
>>>>>>> soundManager
    public float GetMaxEnergy()
    {
        return maxEnergyLevel;
    }

<<<<<<< HEAD
    public float GetLevelScale() => levelScale;

    [Tooltip("adds (or subtracts) the given value to the amount of charge")]
    public void UpdateCharge(float adjustmentAmount)
    {
        chargeLevel = Mathf.Min(energyLevel, chargeLevel + adjustmentAmount);
        chargeLevel = Mathf.Max(0, chargeLevel);

        OnChargeChange.Invoke();

=======

    public void UpdateCharge(float amount)
    {
        chargeLevel = Mathf.Min(energyLevel, chargeLevel + amount);
        OnChargeChange.Invoke();
>>>>>>> soundManager
    }

    public void ResetCharge()
    {
        chargeLevel = 0;
        OnChargeChange.Invoke();
    }

    public float GetCharge()
    {
        return chargeLevel;
    }


<<<<<<< HEAD
    public void EndBoost(int numOfResets, float speedOnExit)
    {
        firedLevel = 0;
        Speed = numOfResets * speedOnExit;
    }


    public void UpdateScore(int amount)
    {
        score += amount;
=======
    public void UpdateScore(int amount)
    {
        score += amount;
        CalculateSpeed(); // could also do this in update depending on how it's implemented, current implementation will only ever change with score
>>>>>>> soundManager
    }

    public int GetScore()
    {
        return score;
    }

<<<<<<< HEAD
    public void PauseGame()
    {

        gameState = GameState.paused;
        Time.timeScale = 0;

        OnGamePause.Invoke();       

    }

    public void ResumeGame()
    {
        gameState = GameState.gameplay;
        Time.timeScale = 1;

        OnGameResume.Invoke();
    }

    public void EnterMenus()
    {
        gameState = GameState.menus;
        Time.timeScale = 0;

        OnGameEnterMenus.Invoke();
    }


    public float GetSpeed() => speedManager.inBoost? speedManager.boostSpeed : firedLevel + Speed;
=======
    public void TogglePause()
    {
        if (paused)
        {
            paused = false;
            Time.timeScale = 1;
            ///wil also want to invoke the pause event

        } else
        {
            paused = true;
            Time.timeScale = 0;
        }

        OnGameTogglePause.Invoke();
    }

    public void CalculateSpeed()
    {
        speed = score / 10;
    }

    public float GetSpeed() => speed;
>>>>>>> soundManager
    public float GetSpeedScale() => speedScale;
}